plugins {
    id("neo-forge")
}

group = "me.gamerduck.rules"
version = "0.0.2-RELEASE"

repositories {
    mavenCentral()
}

base {
    archivesName.set("${rootProject.name}-${project.name}")
}
neoForge {
    // Specify the version of NeoForge to use.
    version = project.property("neo_version") as String

    parchment {
        mappingsVersion = project.property("parchment_mappings_version") as String
        minecraftVersion = project.property("parchment_minecraft_version") as String
    }

    // This line is optional. Access Transformers are automatically detected
//    accessTransformers = project.files("src/main/resources/META-INF/accesstransformer.cfg") as DataFileCollection?

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        create("client") {
            client()

            // Comma-separated list of namespaces to load gametests from. Empty = all namespaces.
            systemProperty("neoforge.enabledGameTestNamespaces", project.property("mod_id") as String)
        }

        create("server") {
            server()
            programArgument("--nogui")
            systemProperty("neoforge.enabledGameTestNamespaces", project.property("mod_id") as String)
        }

        // This run config launches GameTestServer and runs all registered gametests, then exits.
        create("gameTestServer") {
            type = "gameTestServer"
            systemProperty("neoforge.enabledGameTestNamespaces", project.property("mod_id") as String)
        }

        create("data") {
            clientData()

            // example of overriding the workingDirectory set in configureEach above, uncomment if you want to use it
            // gameDirectory = project.file("run-data")

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            programArguments.addAll(
                "--mod", project.property("mod_id") as String,
                "--all",
                "--output", file("src/generated/resources/").absolutePath,
                "--existing", file("src/main/resources/").absolutePath
            )
        }

        configureEach {
            // Recommended logging data for a userdev environment
            systemProperty("forge.logging.markers", "REGISTRIES")

            // Recommended logging level for the console
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        create(project.property("mod_id").toString()) {
            sourceSet(sourceSets.main.get())
        }
    }
}

// Include resources generated by data generators.
sourceSets.main {
    resources {
        srcDir("src/generated/resources")
    }
}

// Sets up a dependency configuration called 'localRuntime'.
val localRuntime: Configuration by configurations.creating
configurations {
    runtimeClasspath.get().extendsFrom(localRuntime)
}

dependencies {
    compileOnly(project(":common"))
    // Example optional mod dependency with JEI
    // compileOnly("mezz.jei:jei-${property("mc_version")}-common-api:${property("jei_version")}")
    // compileOnly("mezz.jei:jei-${property("mc_version")}-neoforge-api:${property("jei_version")}")
    // localRuntime("mezz.jei:jei-${property("mc_version")}-neoforge:${property("jei_version")}")

    // Example mod dependency using a mod jar from ./libs with a flat dir repository
    // implementation("blank:coolmod-${property("mc_version")}:${property("coolmod_version")}")

    // Example mod dependency using a file as dependency
    // implementation(files("libs/coolmod-${property("mc_version")}-${property("coolmod_version")}.jar"))

    // Example project dependency using a sister or child project:
    // implementation(project(":myproject"))
}

// Generate mod metadata by expanding properties into resources
val generateModMetadata by tasks.registering(ProcessResources::class) {
    val replaceProperties = mapOf(
        "minecraft_version" to rootProject.property("minecraft_version"),
        "minecraft_version_range" to rootProject.property("minecraft_version_range"),
        "neo_version" to rootProject.property("neo_version"),
        "mod_id" to rootProject.property("mod_id"),
        "mod_name" to rootProject.property("mod_name"),
        "mod_license" to rootProject.property("mod_license"),
        "mod_version" to rootProject.property("version"),
        "mod_authors" to rootProject.property("authors"),
        "mod_description" to rootProject.property("description")
    )
    inputs.properties(replaceProperties)

    from("src/main/templates") {
        // Only expand non-AT files
        filesMatching("neoforge.mods.toml") { // or any other templates
            expand(replaceProperties)
        }
    }
    into(layout.buildDirectory.dir("generated/sources/modMetadata"))
}

// Include the output of "generateModMetadata" as an input directory for the build
sourceSets.main {
    resources {
        srcDir(generateModMetadata)
    }
}
// To avoid having to run "generateModMetadata" manually, make it run on every project reload
neoForge.ideSyncTask(generateModMetadata)

tasks.withType<JavaCompile>().configureEach {
    options.encoding = "UTF-8" // Use the UTF-8 charset for Java compilation
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        isDownloadSources = true
        isDownloadJavadoc = true
    }
}

tasks.processResources {
    dependsOn(generateModMetadata)
    from(generateModMetadata)

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
tasks.named("createMinecraftArtifacts") {
    dependsOn(tasks.named("generateModMetadata"))
}